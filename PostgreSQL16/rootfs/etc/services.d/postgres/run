#!/usr/bin/with-contenv bashio

# Set up data directory
export PGDATA=/data/postgresql
mkdir -p "$PGDATA"
chown -R postgres:postgres "$PGDATA"
chmod 0700 "$PGDATA"

# Set up runtime directory
mkdir -p /run/postgresql
chown -R postgres:postgres /run/postgresql

# Initialize database if it doesn't exist
if ! bashio::fs.file_exists "$PGDATA/PG_VERSION"; then
    bashio::log.info "Initializing PostgreSQL database..."
    su-exec postgres initdb -D "$PGDATA"
    
    # Configure access - allow all from local network (S6 container networking)
    echo "host all all 0.0.0.0/0 md5" >> "$PGDATA/pg_hba.conf"
    
    # Listen on all interfaces
    echo "listen_addresses = '*'" >> "$PGDATA/postgresql.conf"
fi

# Get config
DB_USER=$(bashio::config 'postgres_user')
DB_PASS=$(bashio::config 'postgres_password')
DB_NAME=$(bashio::config 'postgres_db')

# Start temporary server to create user/db if needed
# Note: In a real robust script we might do this via a temporary socket or ensure we wait, 
# but simply running postgres in background first or using single-user mode is options.
# For simplicity in this add-on run script, we might just start postgres and rely on a post-start hook 
# or use a `createdb` script. 
# Better: Start postgres, wait for it, run setup commands, then keep running? 
# Or just run setup in background if needed?

# Simpler approach: If newly initialized, start in bg, setup, stop.
if [ -f "$PGDATA/PG_VERSION" ] && [ ! -f "$PGDATA/.setup_complete" ]; then
    bashio::log.info "Setting up initial user and database..."
    
    # Start in background
    su-exec postgres postgres -D "$PGDATA" &
    PID=$!
    
    # Wait for start
    until su-exec postgres pg_isready; do
        sleep 1
    done
    
    # Create User and DB
    # We use psql to create user
    bashio::log.info "Creating user ${DB_USER}..."
    su-exec postgres psql -c "CREATE USER \"${DB_USER}\" WITH PASSWORD '${DB_PASS}';"
    
    bashio::log.info "Creating database ${DB_NAME}..."
    su-exec postgres psql -c "CREATE DATABASE \"${DB_NAME}\" OWNER \"${DB_USER}\";"
    
    touch "$PGDATA/.setup_complete"
    
    # Stop background
    kill "$PID"
    wait "$PID"
    bashio::log.info "Database initialization complete!!!"
fi



# Apply custom configuration
bashio::log.info "Applying custom PostgreSQL configuration..."
CUSTOM_CONF="$PGDATA/postgresql.custom.conf"

bashio::log.info "Config parameters: $(bashio::config 'postgres_config')"

# Generic options
if bashio::config.has_value 'postgres_config'; then
    bashio::log.info "Applying custom PostgreSQL configuration..."
    bashio::log.info "Change config parameters: $(bashio::config 'postgres_config')"
    
    bashio::config 'postgres_config' | while read -r config; do
        if [[ -n "${config}" ]]; then
            # Split into key and value
            # We assume config is in "key=value" format
            key=$(echo "${config}" | cut -d '=' -f 1 | xargs)
            value=$(echo "${config}" | cut -d '=' -f 2- | xargs)
            
            if [[ -n "${key}" ]]; then
                bashio::log.info "Setting ${key} to ${value}"
                
                # Check if key exists in config (commented or uncommented)
                if grep -E -q "^#?${key}\s*=" "$PGDATA/postgresql.conf"; then
                    # Replace existing line
                    # Use logical separators for sed to avoid clashes with path values
                    sed -i "s|^#\?${key}\s*=.*|${key} = ${value}|" "$PGDATA/postgresql.conf"
                else
                    # Append new key
                    echo "${key} = ${value}" >> "$PGDATA/postgresql.conf"
                fi
            fi
        fi
    done
fi

bashio::log.info "Starting PostgreSQL..."
exec su-exec postgres postgres -D "$PGDATA"
